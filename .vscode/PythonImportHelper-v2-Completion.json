[
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "E",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "stack",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "bubbleSort",
        "kind": 2,
        "importPath": "Arrays.Sortings.BubbleSort",
        "description": "Arrays.Sortings.BubbleSort",
        "peekOfCode": "def bubbleSort(arr):\n    n = len(arr)\n    # Traverse through all array elements\n    for i in range(n):\n        # Last i elements are already in place\n        for j in range(0, n-i-1):\n            # traverse the array from 0 to n-i-1\n            # Swap if the element found is greater\n            # than the next element\n            if arr[j] > arr[j+1]:",
        "detail": "Arrays.Sortings.BubbleSort",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "Arrays.Sortings.BubbleSort",
        "description": "Arrays.Sortings.BubbleSort",
        "peekOfCode": "arr = [64, 34, 25, 12, 22, 11, 90]\nbubbleSort(arr)\nprint(\"Sorted array is:\")\nfor i in range(len(arr)):\n    print(\"%d\" % arr[i], end=\" \")",
        "detail": "Arrays.Sortings.BubbleSort",
        "documentation": {}
    },
    {
        "label": "heapify",
        "kind": 2,
        "importPath": "Arrays.Sortings.HeapSort",
        "description": "Arrays.Sortings.HeapSort",
        "peekOfCode": "def heapify(arr, n, i):\n    largest = i  # Initialize largest as root\n    l = 2 * i + 1\t # left = 2*i + 1\n    r = 2 * i + 2\t # right = 2*i + 2\n    # See if left child of root exists and is\n    # greater than root\n    if l < n and arr[largest] < arr[l]:\n        largest = l\n    # See if right child of root exists and is\n    # greater than root",
        "detail": "Arrays.Sortings.HeapSort",
        "documentation": {}
    },
    {
        "label": "heapSort",
        "kind": 2,
        "importPath": "Arrays.Sortings.HeapSort",
        "description": "Arrays.Sortings.HeapSort",
        "peekOfCode": "def heapSort(arr):\n    n = len(arr)\n    # Build a maxheap.\n    for i in range(n//2 - 1, -1, -1):\n        heapify(arr, n, i)\n    # One by one extract elements\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # swap\n        heapify(arr, i, 0)\n# Driver code",
        "detail": "Arrays.Sortings.HeapSort",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "Arrays.Sortings.HeapSort",
        "description": "Arrays.Sortings.HeapSort",
        "peekOfCode": "arr = [12, 11, 13, 5, 6, 7]\nheapSort(arr)\nn = len(arr)\nprint(\"Sorted array is\")\nfor i in range(n):\n    print(\"%d\" % arr[i], end=\" \")\n# This code is contributed by Mohit Kumra",
        "detail": "Arrays.Sortings.HeapSort",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "Arrays.Sortings.HeapSort",
        "description": "Arrays.Sortings.HeapSort",
        "peekOfCode": "n = len(arr)\nprint(\"Sorted array is\")\nfor i in range(n):\n    print(\"%d\" % arr[i], end=\" \")\n# This code is contributed by Mohit Kumra",
        "detail": "Arrays.Sortings.HeapSort",
        "documentation": {}
    },
    {
        "label": "insertionSort",
        "kind": 2,
        "importPath": "Arrays.Sortings.InsertionSort",
        "description": "Arrays.Sortings.InsertionSort",
        "peekOfCode": "def insertionSort(arr):\n    # Traverse through 1 to len(arr)\n    for i in range(1, len(arr)):\n        key = arr[i]\n        # Move elements of arr[0..i-1], that are\n        # greater than key, to one position ahead\n        # of their current position\n        j = i-1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]",
        "detail": "Arrays.Sortings.InsertionSort",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "Arrays.Sortings.InsertionSort",
        "description": "Arrays.Sortings.InsertionSort",
        "peekOfCode": "arr = [12, 11, 13, 5, 6]\ninsertionSort(arr)\nfor i in range(len(arr)):\n    print(\"% d\" % arr[i])",
        "detail": "Arrays.Sortings.InsertionSort",
        "documentation": {}
    },
    {
        "label": "mergeSort",
        "kind": 2,
        "importPath": "Arrays.Sortings.MergeSort",
        "description": "Arrays.Sortings.MergeSort",
        "peekOfCode": "def mergeSort(arr):\n    if len(arr) > 1:\n        # Finding the mid of the array\n        mid = len(arr)//2\n        # Dividing the array elements\n        L = arr[:mid]\n        # into 2 halves\n        R = arr[mid:]\n        # Sorting the first half\n        mergeSort(L)",
        "detail": "Arrays.Sortings.MergeSort",
        "documentation": {}
    },
    {
        "label": "printList",
        "kind": 2,
        "importPath": "Arrays.Sortings.MergeSort",
        "description": "Arrays.Sortings.MergeSort",
        "peekOfCode": "def printList(arr):\n    for i in range(len(arr)):\n        print(arr[i], end=\" \")\n    print()\n# Driver Code\nif __name__ == '__main__':\n    arr = [12, 11, 13, 5, 6, 7]\n    print(\"Given array is\", end=\"\\n\")\n    printList(arr)\n    mergeSort(arr)",
        "detail": "Arrays.Sortings.MergeSort",
        "documentation": {}
    },
    {
        "label": "partition",
        "kind": 2,
        "importPath": "Arrays.Sortings.QuickSort",
        "description": "Arrays.Sortings.QuickSort",
        "peekOfCode": "def partition(array, low, high):\n    # Choose the rightmost element as pivot\n    pivot = array[high]\n    # Pointer for greater element\n    i = low - 1\n    # Traverse through all elements\n    # compare each element with pivot\n    for j in range(low, high):\n        if array[j] <= pivot:\n            # If element smaller than pivot is found",
        "detail": "Arrays.Sortings.QuickSort",
        "documentation": {}
    },
    {
        "label": "quick_sort",
        "kind": 2,
        "importPath": "Arrays.Sortings.QuickSort",
        "description": "Arrays.Sortings.QuickSort",
        "peekOfCode": "def quick_sort(array, low, high):\n    if low < high:\n        # Find pivot element such that\n        # element smaller than pivot are on the left\n        # element greater than pivot are on the right\n        pi = partition(array, low, high)\n        # Recursive call on the left of pivot\n        quick_sort(array, low, pi - 1)\n        # Recursive call on the right of pivot\n        quick_sort(array, pi + 1, high)",
        "detail": "Arrays.Sortings.QuickSort",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 5,
        "importPath": "Arrays.Sortings.QuickSort",
        "description": "Arrays.Sortings.QuickSort",
        "peekOfCode": "array = [10, 7, 8, 9, 1, 5]\nquick_sort(array, 0, len(array) - 1)\nprint(f'Sorted array: {array}')\n# This code is contributed by Adnan Aliakbar",
        "detail": "Arrays.Sortings.QuickSort",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "Arrays.Sortings.SelectionSort",
        "description": "Arrays.Sortings.SelectionSort",
        "peekOfCode": "A = [64, 25, 12, 22, 11]\n# Traverse through all array elements\nfor i in range(len(A)):\n    # Find the minimum element in remaining\n    # unsorted array\n    min_index = i\n    for j in range(i+1, len(A)):\n        if A[min_index] > A[j]:\n            min_index = j\n    # Swap the found minimum element with",
        "detail": "Arrays.Sortings.SelectionSort",
        "documentation": {}
    },
    {
        "label": "countSub",
        "kind": 2,
        "importPath": "Google.Distinct Subsequences",
        "description": "Google.Distinct Subsequences",
        "peekOfCode": "def countSub(s):\n    Map = {}\n    # Iterate from 0 to length of s\n    for i in range(len(s)):\n        Map[s[i]] = -1\n    allCount = 0\n    levelCount = 0\n    # Iterate from 0 to length of s\n    for i in range(len(s)):\n        c = s[i]",
        "detail": "Google.Distinct Subsequences",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 5,
        "importPath": "Google.Distinct Subsequences",
        "description": "Google.Distinct Subsequences",
        "peekOfCode": "List = [\"abab\", \"gfg\"]\nfor s in List:\n    cnt = countSub(s)\n    withEmptyString = cnt + 1\n    print(\"With empty string count for\",\n          s, \"is\", withEmptyString)\n    print(\"Without empty string count for\",\n          s, \"is\", cnt)\n# This code is contributed by rag2127",
        "detail": "Google.Distinct Subsequences",
        "documentation": {}
    },
    {
        "label": "editDistDP",
        "kind": 2,
        "importPath": "Google.Edit Distance",
        "description": "Google.Edit Distance",
        "peekOfCode": "def editDistDP(str1, str2, m, n):\n    # Create a table to store results of subproblems\n    dp = [[0 for x in range(n + 1)] for x in range(m + 1)]\n    # Fill d[][] in bottom up manner\n    for i in range(m + 1):\n        for j in range(n + 1):\n            # If first string is empty, only option is to\n            # insert all characters of second string\n            if i == 0:\n                dp[i][j] = j  # Min. operations = j",
        "detail": "Google.Edit Distance",
        "documentation": {}
    },
    {
        "label": "str1",
        "kind": 5,
        "importPath": "Google.Edit Distance",
        "description": "Google.Edit Distance",
        "peekOfCode": "str1 = \"sunday\"\nstr2 = \"saturday\"\nprint(editDistDP(str1, str2, len(str1), len(str2)))\n# This code is contributed by Bhavya Jain",
        "detail": "Google.Edit Distance",
        "documentation": {}
    },
    {
        "label": "str2",
        "kind": 5,
        "importPath": "Google.Edit Distance",
        "description": "Google.Edit Distance",
        "peekOfCode": "str2 = \"saturday\"\nprint(editDistDP(str1, str2, len(str1), len(str2)))\n# This code is contributed by Bhavya Jain",
        "detail": "Google.Edit Distance",
        "documentation": {}
    },
    {
        "label": "gas_station",
        "kind": 2,
        "importPath": "Google.Gas Station",
        "description": "Google.Gas Station",
        "peekOfCode": "def gas_station(gas, cost):\n    begin = 0\n    total = 0\n    fuel = 0\n    for i in range(len(gas)):\n        fuel = fuel + gas[i] - cost[i]\n        if fuel < 0:\n            begin = i+1\n            total = total + fuel\n            fuel = 0",
        "detail": "Google.Gas Station",
        "documentation": {}
    },
    {
        "label": "gas",
        "kind": 5,
        "importPath": "Google.Gas Station",
        "description": "Google.Gas Station",
        "peekOfCode": "gas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]",
        "detail": "Google.Gas Station",
        "documentation": {}
    },
    {
        "label": "cost",
        "kind": 5,
        "importPath": "Google.Gas Station",
        "description": "Google.Gas Station",
        "peekOfCode": "cost = [3, 4, 5, 1, 2]",
        "detail": "Google.Gas Station",
        "documentation": {}
    },
    {
        "label": "findMajority",
        "kind": 2,
        "importPath": "Google.Majority Element",
        "description": "Google.Majority Element",
        "peekOfCode": "def findMajority(arr, size):\n\tm = {}\n\tfor i in range(size):\n\t\tif arr[i] in m:\n\t\t\tm[arr[i]] += 1\n\t\telse:\n\t\t\tm[arr[i]] = 1\n\tcount = 0\n\tfor key in m:\n\t\tif m[key] > size / 2:",
        "detail": "Google.Majority Element",
        "documentation": {}
    },
    {
        "label": "\tm",
        "kind": 5,
        "importPath": "Google.Majority Element",
        "description": "Google.Majority Element",
        "peekOfCode": "\tm = {}\n\tfor i in range(size):\n\t\tif arr[i] in m:\n\t\t\tm[arr[i]] += 1\n\t\telse:\n\t\t\tm[arr[i]] = 1\n\tcount = 0\n\tfor key in m:\n\t\tif m[key] > size / 2:\n\t\t\tcount = 1",
        "detail": "Google.Majority Element",
        "documentation": {}
    },
    {
        "label": "\t\t\tm[arr[i]]",
        "kind": 5,
        "importPath": "Google.Majority Element",
        "description": "Google.Majority Element",
        "peekOfCode": "\t\t\tm[arr[i]] = 1\n\tcount = 0\n\tfor key in m:\n\t\tif m[key] > size / 2:\n\t\t\tcount = 1\n\t\t\tprint(\"Majority found :-\",key)\n\t\t\tbreak\n\tif(count == 0):\n\t\tprint(\"No Majority element\")\n# Driver code",
        "detail": "Google.Majority Element",
        "documentation": {}
    },
    {
        "label": "\tcount",
        "kind": 5,
        "importPath": "Google.Majority Element",
        "description": "Google.Majority Element",
        "peekOfCode": "\tcount = 0\n\tfor key in m:\n\t\tif m[key] > size / 2:\n\t\t\tcount = 1\n\t\t\tprint(\"Majority found :-\",key)\n\t\t\tbreak\n\tif(count == 0):\n\t\tprint(\"No Majority element\")\n# Driver code\narr = [2, 2, 2, 2, 5, 5, 2, 3, 3]",
        "detail": "Google.Majority Element",
        "documentation": {}
    },
    {
        "label": "\t\t\tcount",
        "kind": 5,
        "importPath": "Google.Majority Element",
        "description": "Google.Majority Element",
        "peekOfCode": "\t\t\tcount = 1\n\t\t\tprint(\"Majority found :-\",key)\n\t\t\tbreak\n\tif(count == 0):\n\t\tprint(\"No Majority element\")\n# Driver code\narr = [2, 2, 2, 2, 5, 5, 2, 3, 3]\nn = len(arr)\n# Function calling\nfindMajority(arr, n)",
        "detail": "Google.Majority Element",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "Google.Majority Element",
        "description": "Google.Majority Element",
        "peekOfCode": "arr = [2, 2, 2, 2, 5, 5, 2, 3, 3]\nn = len(arr)\n# Function calling\nfindMajority(arr, n)\n# This code is contributed by ankush_953\n# Moore voting algorithm\n# # Function to find the candidate for Majority\n# # Complexity Analysis: \n# # Time Complexity: O(n). \n#     # As two traversal of the array is needed, so the time complexity is linear.",
        "detail": "Google.Majority Element",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "Google.Majority Element",
        "description": "Google.Majority Element",
        "peekOfCode": "n = len(arr)\n# Function calling\nfindMajority(arr, n)\n# This code is contributed by ankush_953\n# Moore voting algorithm\n# # Function to find the candidate for Majority\n# # Complexity Analysis: \n# # Time Complexity: O(n). \n#     # As two traversal of the array is needed, so the time complexity is linear.\n# # Auxiliary Space: O(1). ",
        "detail": "Google.Majority Element",
        "documentation": {}
    },
    {
        "label": "maximumTime",
        "kind": 2,
        "importPath": "Google.Maximum Time",
        "description": "Google.Maximum Time",
        "peekOfCode": "def maximumTime(s):\n    s = list(s)\n    if s[0] == \"?\":\n        if s[1] == \"?\":\n            s[0] = \"2\"\n            s[1] = \"3\"\n        elif int(s[1]) >= 0 and int(s[1]) < 4:\n            s[0] = \"2\"\n        elif int(s[1]) >= 0 and int(s[1]) <= 9:\n            s[0] = \"1\"",
        "detail": "Google.Maximum Time",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Google.Maximum size rectangle binary sub-matrix with all 1s",
        "description": "Google.Maximum size rectangle binary sub-matrix with all 1s",
        "peekOfCode": "class Solution():\n    def maxHist(self, row):\n        # Create an empty stack. The stack holds\n        # indexes of hist array / The bars stored\n        # in stack are always in increasing order\n        # of their heights.\n        result = []\n        # Top of stack\n        top_val = 0\n        # Initialize max area in current",
        "detail": "Google.Maximum size rectangle binary sub-matrix with all 1s",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Google.Min Amplitude",
        "description": "Google.Min Amplitude",
        "peekOfCode": "class Solution:\n    def minDifference(self, nums: List[int]) -> int:\n        if len(nums) <= 4:\n            return 0\n        nums.sort()\n        return min(nums[-1] - nums[3], nums[-2] - nums[2], nums[-3] - nums[1], nums[-4] - nums[0])",
        "detail": "Google.Min Amplitude",
        "documentation": {}
    },
    {
        "label": "minJumps",
        "kind": 2,
        "importPath": "Google.Min Jump Arrays",
        "description": "Google.Min Jump Arrays",
        "peekOfCode": "def minJumps(arr, n):\n    jumps = [0 for i in range(n)]\n    if (n == 0) or (arr[0] == 0):\n        return float('inf')\n    jumps[0] = 0\n    # Find the minimum number of\n    # jumps to reach arr[i] from\n    # arr[0] and assign this\n    # value to jumps[i]\n    for i in range(1, n):",
        "detail": "Google.Min Jump Arrays",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "Google.Min Jump Arrays",
        "description": "Google.Min Jump Arrays",
        "peekOfCode": "arr = [1, 3, 6, 1, 0, 9]\nsize = len(arr)\nprint('Minimum number of jumps to reach',\n      'end is', minJumps(arr, size))\n# This code is contributed by Soumen Ghosh",
        "detail": "Google.Min Jump Arrays",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "Google.Min Jump Arrays",
        "description": "Google.Min Jump Arrays",
        "peekOfCode": "size = len(arr)\nprint('Minimum number of jumps to reach',\n      'end is', minJumps(arr, size))\n# This code is contributed by Soumen Ghosh",
        "detail": "Google.Min Jump Arrays",
        "documentation": {}
    },
    {
        "label": "ispalindrome",
        "kind": 2,
        "importPath": "Google.Palidrome Partition",
        "description": "Google.Palidrome Partition",
        "peekOfCode": "def ispalindrome(input, start, end):\n    # Using two pointer technique to check palindrome\n    while (start < end):\n        if (input[start] != input[end]):\n            return False\n        start += 1\n        end -= 1\n    return True\n# Function to find keys for the Hashmap\ndef convert(a, b):",
        "detail": "Google.Palidrome Partition",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "Google.Palidrome Partition",
        "description": "Google.Palidrome Partition",
        "peekOfCode": "def convert(a, b):\n    return str(a) + str(b)\n# Returns the minimum number of cuts needed to partition a string\n# such that every part is a palindrome\ndef minpalparti_memo(input, i, j, memo):\n    if (i > j):\n        return 0\n    # Key for the Input String\n    ij = convert(i, j)\n    # If the no of partitions for string \"ij\" is already calculated",
        "detail": "Google.Palidrome Partition",
        "documentation": {}
    },
    {
        "label": "minpalparti_memo",
        "kind": 2,
        "importPath": "Google.Palidrome Partition",
        "description": "Google.Palidrome Partition",
        "peekOfCode": "def minpalparti_memo(input, i, j, memo):\n    if (i > j):\n        return 0\n    # Key for the Input String\n    ij = convert(i, j)\n    # If the no of partitions for string \"ij\" is already calculated\n    # then return the calculated value using the Hashmap\n    if (ij in memo):\n        return memo[ij]\n    # Every String of length 1 is a palindrome",
        "detail": "Google.Palidrome Partition",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Google.Ways to Split String",
        "description": "Google.Ways to Split String",
        "peekOfCode": "class Solution:\n    def numSplits(self, s: str) -> int:\n            res = 0\n            f_right, f_left = {}, {}\n            for c in s:\n                f_right[c] = 1 + f_right.get(c, 0)\n            print(f_right)\n            for c in s:\n                f_left[c] = 1 + f_left.get(c, 0)\n                f_right[c] -= 1",
        "detail": "Google.Ways to Split String",
        "documentation": {}
    },
    {
        "label": "wordBreak",
        "kind": 2,
        "importPath": "Google.Word Break",
        "description": "Google.Word Break",
        "peekOfCode": "def wordBreak(s, dictionary):\n\t# create a dp table to store results of subproblems\n\t# value of dp[i] will be true if string s can be segmented\n\t# into dictionary words from 0 to i.\n\tdp = [False for i in range(len(s) + 1)]\n\t# dp[0] is true because an empty string can always be segmented.\n\tdp[0] = True\n\tfor i in range(len(s) + 1):\n\t\tfor j in range(i):\n\t\t\tif dp[j] and s[j: i] in dictionary:",
        "detail": "Google.Word Break",
        "documentation": {}
    },
    {
        "label": "\tdp",
        "kind": 5,
        "importPath": "Google.Word Break",
        "description": "Google.Word Break",
        "peekOfCode": "\tdp = [False for i in range(len(s) + 1)]\n\t# dp[0] is true because an empty string can always be segmented.\n\tdp[0] = True\n\tfor i in range(len(s) + 1):\n\t\tfor j in range(i):\n\t\t\tif dp[j] and s[j: i] in dictionary:\n\t\t\t\tdp[i] = True\n\t\t\t\tbreak\n\treturn dp[len(s)]\n# driver code",
        "detail": "Google.Word Break",
        "documentation": {}
    },
    {
        "label": "\tdp[0]",
        "kind": 5,
        "importPath": "Google.Word Break",
        "description": "Google.Word Break",
        "peekOfCode": "\tdp[0] = True\n\tfor i in range(len(s) + 1):\n\t\tfor j in range(i):\n\t\t\tif dp[j] and s[j: i] in dictionary:\n\t\t\t\tdp[i] = True\n\t\t\t\tbreak\n\treturn dp[len(s)]\n# driver code\ndictionary = [ \"mobile\", \"samsung\", \"sam\", \"sung\", \"man\", \"mango\", \"icecream\", \"and\", \"go\", \"i\", \"like\", \"ice\", \"cream\" ]\ndict = set()",
        "detail": "Google.Word Break",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tdp[i]",
        "kind": 5,
        "importPath": "Google.Word Break",
        "description": "Google.Word Break",
        "peekOfCode": "\t\t\t\tdp[i] = True\n\t\t\t\tbreak\n\treturn dp[len(s)]\n# driver code\ndictionary = [ \"mobile\", \"samsung\", \"sam\", \"sung\", \"man\", \"mango\", \"icecream\", \"and\", \"go\", \"i\", \"like\", \"ice\", \"cream\" ]\ndict = set()\nfor s in dictionary:\n\tdict.add(s)\nif (wordBreak(\"ilikesamsung\", dict)):\n\tprint(\"Yes\")",
        "detail": "Google.Word Break",
        "documentation": {}
    },
    {
        "label": "dictionary",
        "kind": 5,
        "importPath": "Google.Word Break",
        "description": "Google.Word Break",
        "peekOfCode": "dictionary = [ \"mobile\", \"samsung\", \"sam\", \"sung\", \"man\", \"mango\", \"icecream\", \"and\", \"go\", \"i\", \"like\", \"ice\", \"cream\" ]\ndict = set()\nfor s in dictionary:\n\tdict.add(s)\nif (wordBreak(\"ilikesamsung\", dict)):\n\tprint(\"Yes\")\nelse :\n\tprint(\"No\")\nif (wordBreak(\"iiiiiiii\", dict)):\n\tprint(\"Yes\")",
        "detail": "Google.Word Break",
        "documentation": {}
    },
    {
        "label": "dict",
        "kind": 5,
        "importPath": "Google.Word Break",
        "description": "Google.Word Break",
        "peekOfCode": "dict = set()\nfor s in dictionary:\n\tdict.add(s)\nif (wordBreak(\"ilikesamsung\", dict)):\n\tprint(\"Yes\")\nelse :\n\tprint(\"No\")\nif (wordBreak(\"iiiiiiii\", dict)):\n\tprint(\"Yes\")\nelse:",
        "detail": "Google.Word Break",
        "documentation": {}
    },
    {
        "label": "dijkstra",
        "kind": 2,
        "importPath": "Graphs Traversal.dijkstra",
        "description": "Graphs Traversal.dijkstra",
        "peekOfCode": "def dijkstra(edges, f, t):\n    g = defaultdict(list)\n    for l, r, c in edges:\n        g[l].append((c, r))\n    q = [(0, f, ())]\n    seen = set()\n    mins = {f: 0}\n    while q:\n        # Remove the smallest element from the heap, and maintaining th heap variant\n        (cost, v1, path) = heappop(q)",
        "detail": "Graphs Traversal.dijkstra",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "Linked List.LL_add_two_numbers",
        "description": "Linked List.LL_add_two_numbers",
        "peekOfCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def sumListValues(self, l):\n        if not l:\n            return ''\n        return str(l.val) + self.sumListValues(l.next)\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:",
        "detail": "Linked List.LL_add_two_numbers",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.LL_add_two_numbers",
        "description": "Linked List.LL_add_two_numbers",
        "peekOfCode": "class Solution:\n    def sumListValues(self, l):\n        if not l:\n            return ''\n        return str(l.val) + self.sumListValues(l.next)\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        val1 = int(str(self.sumListValues(l1))[::-1])\n        val2 = int(str(self.sumListValues(l2))[::-1])\n        result =  str(val1 + val2)\n        root = None",
        "detail": "Linked List.LL_add_two_numbers",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.[old] partition_list",
        "description": "Linked List.[old] partition_list",
        "peekOfCode": "class Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        before = []\n        after = []\n        curr = head\n        flag = False\n        # If empty or single element\n        if not head or not head.next:\n            return head\n        # find x head and split between before and after",
        "detail": "Linked List.[old] partition_list",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.[old] reverse_nodes_in_kth_group",
        "description": "Linked List.[old] reverse_nodes_in_kth_group",
        "peekOfCode": "class Solution:\n    def traverse(self, head):\n        if not head:\n            return []\n        return [head.val] + self.traverse(head.next)\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        values = []\n        items = self.traverse(head)\n        val = []\n        n = len(items)",
        "detail": "Linked List.[old] reverse_nodes_in_kth_group",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "Linked List.avl-tree",
        "description": "Linked List.avl-tree",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.height = 1\n# AVL tree class which supports the\n# Insert operation\nclass AVL_Tree(object):\n    # Recursive function to insert key in",
        "detail": "Linked List.avl-tree",
        "documentation": {}
    },
    {
        "label": "AVL_Tree",
        "kind": 6,
        "importPath": "Linked List.avl-tree",
        "description": "Linked List.avl-tree",
        "peekOfCode": "class AVL_Tree(object):\n    # Recursive function to insert key in\n    # subtree rooted with node and returns\n    # new root of subtree.\n    def insert(self, root, key):\n        # Step 1 - Perform normal BST\n        if not root:\n            return TreeNode(key)\n        elif key < root.val:\n            root.left = self.insert(root.left, key)",
        "detail": "Linked List.avl-tree",
        "documentation": {}
    },
    {
        "label": "myTree",
        "kind": 5,
        "importPath": "Linked List.avl-tree",
        "description": "Linked List.avl-tree",
        "peekOfCode": "myTree = AVL_Tree()\nroot = None\nroot = myTree.insert(root, 10)\nroot = myTree.insert(root, 20)\nroot = myTree.insert(root, 30)\nroot = myTree.insert(root, 40)\nroot = myTree.insert(root, 50)\nroot = myTree.insert(root, 25)\n# Preorder Traversal\nprint(\"Preorder traversal of the\",",
        "detail": "Linked List.avl-tree",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "Linked List.avl-tree",
        "description": "Linked List.avl-tree",
        "peekOfCode": "root = None\nroot = myTree.insert(root, 10)\nroot = myTree.insert(root, 20)\nroot = myTree.insert(root, 30)\nroot = myTree.insert(root, 40)\nroot = myTree.insert(root, 50)\nroot = myTree.insert(root, 25)\n# Preorder Traversal\nprint(\"Preorder traversal of the\",\n      \"constructed AVL tree is\")",
        "detail": "Linked List.avl-tree",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "Linked List.avl-tree",
        "description": "Linked List.avl-tree",
        "peekOfCode": "root = myTree.insert(root, 10)\nroot = myTree.insert(root, 20)\nroot = myTree.insert(root, 30)\nroot = myTree.insert(root, 40)\nroot = myTree.insert(root, 50)\nroot = myTree.insert(root, 25)\n# Preorder Traversal\nprint(\"Preorder traversal of the\",\n      \"constructed AVL tree is\")\nprint(myTree.preOrder(root))",
        "detail": "Linked List.avl-tree",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "Linked List.avl-tree",
        "description": "Linked List.avl-tree",
        "peekOfCode": "root = myTree.insert(root, 20)\nroot = myTree.insert(root, 30)\nroot = myTree.insert(root, 40)\nroot = myTree.insert(root, 50)\nroot = myTree.insert(root, 25)\n# Preorder Traversal\nprint(\"Preorder traversal of the\",\n      \"constructed AVL tree is\")\nprint(myTree.preOrder(root))\n# This code is contributed by Ajitesh Pathak",
        "detail": "Linked List.avl-tree",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "Linked List.avl-tree",
        "description": "Linked List.avl-tree",
        "peekOfCode": "root = myTree.insert(root, 30)\nroot = myTree.insert(root, 40)\nroot = myTree.insert(root, 50)\nroot = myTree.insert(root, 25)\n# Preorder Traversal\nprint(\"Preorder traversal of the\",\n      \"constructed AVL tree is\")\nprint(myTree.preOrder(root))\n# This code is contributed by Ajitesh Pathak",
        "detail": "Linked List.avl-tree",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "Linked List.avl-tree",
        "description": "Linked List.avl-tree",
        "peekOfCode": "root = myTree.insert(root, 40)\nroot = myTree.insert(root, 50)\nroot = myTree.insert(root, 25)\n# Preorder Traversal\nprint(\"Preorder traversal of the\",\n      \"constructed AVL tree is\")\nprint(myTree.preOrder(root))\n# This code is contributed by Ajitesh Pathak",
        "detail": "Linked List.avl-tree",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "Linked List.avl-tree",
        "description": "Linked List.avl-tree",
        "peekOfCode": "root = myTree.insert(root, 50)\nroot = myTree.insert(root, 25)\n# Preorder Traversal\nprint(\"Preorder traversal of the\",\n      \"constructed AVL tree is\")\nprint(myTree.preOrder(root))\n# This code is contributed by Ajitesh Pathak",
        "detail": "Linked List.avl-tree",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "Linked List.avl-tree",
        "description": "Linked List.avl-tree",
        "peekOfCode": "root = myTree.insert(root, 25)\n# Preorder Traversal\nprint(\"Preorder traversal of the\",\n      \"constructed AVL tree is\")\nprint(myTree.preOrder(root))\n# This code is contributed by Ajitesh Pathak",
        "detail": "Linked List.avl-tree",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Linked List.binary-search-tree",
        "description": "Linked List.binary-search-tree",
        "peekOfCode": "class Node:\n    def __init__(self, key) -> None:\n        self.left = None\n        self.key = key\n        self.right = None\nclass BinarySearchTree:\n    r = None\n    def __init__(self, items=[]) -> None:\n        assert len(items), \"Empty list of items\"\n        for (i, key) in enumerate(items):",
        "detail": "Linked List.binary-search-tree",
        "documentation": {}
    },
    {
        "label": "BinarySearchTree",
        "kind": 6,
        "importPath": "Linked List.binary-search-tree",
        "description": "Linked List.binary-search-tree",
        "peekOfCode": "class BinarySearchTree:\n    r = None\n    def __init__(self, items=[]) -> None:\n        assert len(items), \"Empty list of items\"\n        for (i, key) in enumerate(items):\n            if i is 0:\n                self.r = self.insert(root=None, key=key)\n            else:\n                if self.r.key == key:\n                    return self.r",
        "detail": "Linked List.binary-search-tree",
        "documentation": {}
    },
    {
        "label": "findLowIndex",
        "kind": 2,
        "importPath": "Linked List.find_low_high_index",
        "description": "Linked List.find_low_high_index",
        "peekOfCode": "def findLowIndex(A, key):\n    low = 0\n    high = len(A) - 1\n    mid = high // 2\n    while low <= high:\n        midValue = A[mid]\n        if midValue < key:\n            low = mid + 1\n        else:\n            high = mid - 1",
        "detail": "Linked List.find_low_high_index",
        "documentation": {}
    },
    {
        "label": "findHighIndex",
        "kind": 2,
        "importPath": "Linked List.find_low_high_index",
        "description": "Linked List.find_low_high_index",
        "peekOfCode": "def findHighIndex(A, key):\n    low = 0\n    high = len(A) - 1\n    mid = high // 2\n    while low <= high:\n        midValue = A[mid]\n        if midValue <= key:\n            low = mid + 1\n        else:\n            high = mid - 1",
        "detail": "Linked List.find_low_high_index",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "Linked List.graph",
        "description": "Linked List.graph",
        "peekOfCode": "class Graph:\n    def __init__(self, graph):\n        if not graph:\n            graph = {}\n        self.graph = graph\n    def getVertices(self):\n        return self.graph.keys()\n    def getEdges(self):\n        edges = []\n        for vertex in self.graph:",
        "detail": "Linked List.graph",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Linked List.heap_tree",
        "description": "Linked List.heap_tree",
        "peekOfCode": "class Node:\n    def __init__(self, key):\n        self.right = None\n        self.value = key\n        self.left = None\nclass HeapTree:\n    def left(self, k):\n        return 2*k + 1\n    def right(self, k):\n        return 2*k + 2",
        "detail": "Linked List.heap_tree",
        "documentation": {}
    },
    {
        "label": "HeapTree",
        "kind": 6,
        "importPath": "Linked List.heap_tree",
        "description": "Linked List.heap_tree",
        "peekOfCode": "class HeapTree:\n    def left(self, k):\n        return 2*k + 1\n    def right(self, k):\n        return 2*k + 2\n    def max_heapify(self, A, k):\n        l = self.left(k)\n        r = self.right(k)\n        largest = k\n        if l < len(A) and A[l] > A[k]:",
        "detail": "Linked List.heap_tree",
        "documentation": {}
    },
    {
        "label": "knapsack",
        "kind": 2,
        "importPath": "Linked List.knapsack-0-1",
        "description": "Linked List.knapsack-0-1",
        "peekOfCode": "def knapsack(C, wt, val, n):\n    if not n or not C:\n        return 0\n    # If weight is more than Capacity we cannot pick that item. So need to ignore the weight\n    if wt[n - 1] > C:\n        return knapsack(C, wt, val, n-1)\n    else:\n        return max(val[n-1] + knapsack(C - wt[n - 1], wt, val, n - 1), knapsack(C, wt, val, n - 1))\nif __name__ == \"__main__\":\n    # Items value and weight",
        "detail": "Linked List.knapsack-0-1",
        "documentation": {}
    },
    {
        "label": "Item",
        "kind": 6,
        "importPath": "Linked List.knapsack_fractional",
        "description": "Linked List.knapsack_fractional",
        "peekOfCode": "class Item:\n    def __init__(self, wt, val, index):\n        self.wt = wt\n        self.val = val\n        self.index = index\n        self.cost = val // wt\n    def __lt__(self, other):\n        return self.cost < other.cost\ndef getMaxValue(C, wt, val):\n    items = []",
        "detail": "Linked List.knapsack_fractional",
        "documentation": {}
    },
    {
        "label": "getMaxValue",
        "kind": 2,
        "importPath": "Linked List.knapsack_fractional",
        "description": "Linked List.knapsack_fractional",
        "peekOfCode": "def getMaxValue(C, wt, val):\n    items = []\n    for i in range(len(wt)):\n        items.append(Item(wt[i], val[i], i))\n    # sorting items by cost\n    items.sort(reverse=True)\n    totalValue = 0\n    for item in items:\n        curWt = int(item.wt)\n        curVal = int(item.val)",
        "detail": "Linked List.knapsack_fractional",
        "documentation": {}
    },
    {
        "label": "LRU",
        "kind": 6,
        "importPath": "Linked List.lru_cache",
        "description": "Linked List.lru_cache",
        "peekOfCode": "class LRU:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = set()\n        self.cache_vals = LinkedList()\n    def get(self, value):\n        if value not in self.cache:\n            return None\n        else:\n            return self.cache_vals.index(value) ",
        "detail": "Linked List.lru_cache",
        "documentation": {}
    },
    {
        "label": "LinkedList",
        "kind": 5,
        "importPath": "Linked List.lru_cache",
        "description": "Linked List.lru_cache",
        "peekOfCode": "LinkedList = collections.deque\nclass LRU:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = set()\n        self.cache_vals = LinkedList()\n    def get(self, value):\n        if value not in self.cache:\n            return None\n        else:",
        "detail": "Linked List.lru_cache",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.merge_k_sorted_lists",
        "description": "Linked List.merge_k_sorted_lists",
        "peekOfCode": "class Solution:\n    def traverse(self, node):\n        if not node:\n            return []\n        return [node.val] + self.traverse(node.next)\n    def merge(self, h1, h2):\n        if not h1:\n            return h2\n        if not h2:\n            return h1",
        "detail": "Linked List.merge_k_sorted_lists",
        "documentation": {}
    },
    {
        "label": "Pair",
        "kind": 6,
        "importPath": "Linked List.merge_overlapping_intervals",
        "description": "Linked List.merge_overlapping_intervals",
        "peekOfCode": "class Pair:\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n    def __str__(self) -> str:\n        return str(self.first) + \" \" + str(self.second)\ndef mergeOverlappingIntervals(A):\n    result = []\n    result.append(A[0])\n    for i in range(1, len(A)):",
        "detail": "Linked List.merge_overlapping_intervals",
        "documentation": {}
    },
    {
        "label": "mergeOverlappingIntervals",
        "kind": 2,
        "importPath": "Linked List.merge_overlapping_intervals",
        "description": "Linked List.merge_overlapping_intervals",
        "peekOfCode": "def mergeOverlappingIntervals(A):\n    result = []\n    result.append(A[0])\n    for i in range(1, len(A)):\n        # Looped interval\n        fi = A[i].first\n        si = A[i].second\n        # Last selected Interval\n        f = result[len(result) - 1].first\n        s = result[len(result) - 1].second",
        "detail": "Linked List.merge_overlapping_intervals",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.merge_two_sorted_list_best_case",
        "description": "Linked List.merge_two_sorted_list_best_case",
        "peekOfCode": "class Solution:\n    def merge(self, h1, h2):\n        if not h1:\n            return h2\n        if not h2:\n            return h1\n        if h1.val < h2.val:\n            h1.next = self.merge(h1.next, h2)\n            return h1\n        else:",
        "detail": "Linked List.merge_two_sorted_list_best_case",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.merge_two_sorted_list_with_list",
        "description": "Linked List.merge_two_sorted_list_with_list",
        "peekOfCode": "class Solution:\n    def traverse(self, l):\n        if not l:\n            return []\n        return [l] + self.traverse(l.next)        \n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        result = self.traverse(list1) + self.traverse(list2)\n        result.sort(key=getKey)\n        for i in range(len(result) - 1):\n            result[i].next = result[i+1]",
        "detail": "Linked List.merge_two_sorted_list_with_list",
        "documentation": {}
    },
    {
        "label": "getKey",
        "kind": 2,
        "importPath": "Linked List.merge_two_sorted_list_with_list",
        "description": "Linked List.merge_two_sorted_list_with_list",
        "peekOfCode": "def getKey(node):\n    return node.val\nclass Solution:\n    def traverse(self, l):\n        if not l:\n            return []\n        return [l] + self.traverse(l.next)        \n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        result = self.traverse(list1) + self.traverse(list2)\n        result.sort(key=getKey)",
        "detail": "Linked List.merge_two_sorted_list_with_list",
        "documentation": {}
    },
    {
        "label": "moveZeros",
        "kind": 2,
        "importPath": "Linked List.move_zeros_to_left",
        "description": "Linked List.move_zeros_to_left",
        "peekOfCode": "def moveZeros(A):\n    l = len(A)\n    read = l - 1\n    write = l - 1\n    while(read >= 0):\n        print(\"read\", read, A[read])\n        if A[read] != 0:\n            print(\"write\", write, A[write])\n            temp = A[write]\n            A[write] = A[read]",
        "detail": "Linked List.move_zeros_to_left",
        "documentation": {}
    },
    {
        "label": "evaluatePostfixExpression",
        "kind": 2,
        "importPath": "Linked List.postfix-evaluation",
        "description": "Linked List.postfix-evaluation",
        "peekOfCode": "def evaluatePostfixExpression(E=[]):\n    # Initialization\n    stack = []\n    assert len(E), \"No expression detected\"\n    for value in E:\n        # Check Operand\n        print(value, stack, len(stack))\n        if isinstance(value, int):\n            stack.append(int(value))\n            pass",
        "detail": "Linked List.postfix-evaluation",
        "documentation": {}
    },
    {
        "label": "operators",
        "kind": 5,
        "importPath": "Linked List.postfix-evaluation",
        "description": "Linked List.postfix-evaluation",
        "peekOfCode": "operators = {\n    \"+\": operator.add,\n    \"-\": operator.sub,\n    \"*\": operator.mul,\n    \"/\": operator.truediv,\n    \"%\": operator.mod,\n    \"^\": operator.xor\n}\ndef evaluatePostfixExpression(E=[]):\n    # Initialization",
        "detail": "Linked List.postfix-evaluation",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.remove_duplicate_with_sorted_list",
        "description": "Linked List.remove_duplicate_with_sorted_list",
        "peekOfCode": "class Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ref = set()\n        current = head\n        while current:\n            ref.add(current.val)\n            current = current.next\n        ref = list(ref)\n        ref.sort()\n        root = None",
        "detail": "Linked List.remove_duplicate_with_sorted_list",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.remove_duplicates_and_get_unique_list_items",
        "description": "Linked List.remove_duplicates_and_get_unique_list_items",
        "peekOfCode": "class Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ref = {}\n        current = head\n        while current:\n            key = current.val\n            if key in ref:\n                ref[key] = ref[key] + 1\n            else:\n                ref[key] = 1",
        "detail": "Linked List.remove_duplicates_and_get_unique_list_items",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.reverse_linked_list",
        "description": "Linked List.reverse_linked_list",
        "peekOfCode": "class Solution:\n    def reverse(self, head):\n        prev = None\n        current = head\n        while current:\n            next = current.next\n            current.next = prev\n            prev = current\n            current = next\n        return prev",
        "detail": "Linked List.reverse_linked_list",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.reverse_linked_list_2",
        "description": "Linked List.reverse_linked_list_2",
        "peekOfCode": "class Solution:\n    def reverse(self, head, start, end):\n        prev = None\n        current = head\n        while current and end > 0:\n            next = current.next\n            if start == 1:\n                current.next = prev\n                prev = current\n            else:",
        "detail": "Linked List.reverse_linked_list_2",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.reverse_nodes_in_kth_group",
        "description": "Linked List.reverse_nodes_in_kth_group",
        "peekOfCode": "class Solution:\n    def reverse(self, head, k):\n        if not head:\n            return head\n        current = head\n        prev = None\n        next = None\n        count = 0\n        # validate do we have k elements in head or not\n        while current is not None and count < k:",
        "detail": "Linked List.reverse_nodes_in_kth_group",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.rotate_list_kth",
        "description": "Linked List.rotate_list_kth",
        "peekOfCode": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        current = head\n        l = 1\n        # validate whether list is not blank or single element\n        if not current or not current.next:\n            return head\n        # go to the last element\n        while current.next:\n            current = current.next",
        "detail": "Linked List.rotate_list_kth",
        "documentation": {}
    },
    {
        "label": "ListStack",
        "kind": 6,
        "importPath": "Linked List.stack",
        "description": "Linked List.stack",
        "peekOfCode": "class ListStack:\n    stack = []\n    _size = 0\n    _top = -1\n    def __init__(self, size):\n        self._size = size\n    def __str__(self):\n        assert not self.isEmpty(), \"Stack is empty\"\n        return ', '.join(list(map(str, self.stack[:self._top+1])))\n        # return ', '.join([str(self.stack[value]) for value in range(0, self._top + 1)])",
        "detail": "Linked List.stack",
        "documentation": {}
    },
    {
        "label": "split",
        "kind": 2,
        "importPath": "Linked List.string_methods",
        "description": "Linked List.string_methods",
        "peekOfCode": "def split(word):\n    return [char for char in word]\n# If pattern for split\nprint(a.split(\" \"))",
        "detail": "Linked List.string_methods",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Linked List.string_methods",
        "description": "Linked List.string_methods",
        "peekOfCode": "a = \"102\"\na = a[::-1]\n## Split and convert to list\n# If no white spaces\nprint(list(map(int, a)))\ndef split(word):\n    return [char for char in word]\n# If pattern for split\nprint(a.split(\" \"))",
        "detail": "Linked List.string_methods",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Linked List.string_methods",
        "description": "Linked List.string_methods",
        "peekOfCode": "a = a[::-1]\n## Split and convert to list\n# If no white spaces\nprint(list(map(int, a)))\ndef split(word):\n    return [char for char in word]\n# If pattern for split\nprint(a.split(\" \"))",
        "detail": "Linked List.string_methods",
        "documentation": {}
    },
    {
        "label": "sumOfTwo",
        "kind": 2,
        "importPath": "Linked List.sum_of_two_values",
        "description": "Linked List.sum_of_two_values",
        "peekOfCode": "def sumOfTwo(A, val):\n    s = set()\n    for a in A:\n        if val - a in s:\n            return True\n        s.add(a)\n    return False\nif __name__ == \"__main__\":\n    v = [5, 7, 1, 2, 8, 4, 3]\n    test = [3, 20, 1, 2, 7]",
        "detail": "Linked List.sum_of_two_values",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Linked List.swap_nodes_in_pair",
        "description": "Linked List.swap_nodes_in_pair",
        "peekOfCode": "class Solution:\n    def swap(self, head):\n        if not head:\n            return head\n        if head.next:\n            next = head.next.next\n            temp = head.next\n            head.next = self.swap(next)\n            temp.next = head\n            return temp",
        "detail": "Linked List.swap_nodes_in_pair",
        "documentation": {}
    },
    {
        "label": "computeLPSArray",
        "kind": 2,
        "importPath": "String.KMP_pattern_search",
        "description": "String.KMP_pattern_search",
        "peekOfCode": "def computeLPSArray(pat, pattern_len, lps):\n    # length of the previous longest predix suffix\n    len = 0\n    # lps[0] is always 0\n    lps[0]\n    i = 1\n    while i < pattern_len:\n        if pat[i] == pat[len]:\n            len += 1\n            lps[i] = len",
        "detail": "String.KMP_pattern_search",
        "documentation": {}
    },
    {
        "label": "KMPSearch",
        "kind": 2,
        "importPath": "String.KMP_pattern_search",
        "description": "String.KMP_pattern_search",
        "peekOfCode": "def KMPSearch(pat, text):\n    pattern_len = len(pat)\n    text_len = len(text)\n    # create lps (longest prefix suffix)\n    lps = [0]*pattern_len\n    # index for the pattern\n    j = 0\n    # preprocess the pattern\n    computeLPSArray(pat, pattern_len, lps)\n    # index of text",
        "detail": "String.KMP_pattern_search",
        "documentation": {}
    },
    {
        "label": "search",
        "kind": 2,
        "importPath": "String.rabin_karp_pattern_search",
        "description": "String.rabin_karp_pattern_search",
        "peekOfCode": "def search(pat, txt, q):\n    M = len(pat)\n    N = len(txt)\n    i = 0  # index for pattern\n    j = 0  # index for text\n    p = 0  # hash value for pattern\n    t = 0  # hash value for text\n    h = 1  #\n    for i in range(M-1):\n        h = (h*NO_OF_CHARS) % q",
        "detail": "String.rabin_karp_pattern_search",
        "documentation": {}
    },
    {
        "label": "NO_OF_CHARS",
        "kind": 5,
        "importPath": "String.rabin_karp_pattern_search",
        "description": "String.rabin_karp_pattern_search",
        "peekOfCode": "NO_OF_CHARS = 256\ndef search(pat, txt, q):\n    M = len(pat)\n    N = len(txt)\n    i = 0  # index for pattern\n    j = 0  # index for text\n    p = 0  # hash value for pattern\n    t = 0  # hash value for text\n    h = 1  #\n    for i in range(M-1):",
        "detail": "String.rabin_karp_pattern_search",
        "documentation": {}
    },
    {
        "label": "txt",
        "kind": 5,
        "importPath": "String.regex",
        "description": "String.regex",
        "peekOfCode": "txt = \"The rain in Spain\"\nx = re.search(\"rain\", txt)\ny = re.findall(\"rain\", txt)\nz = re.split(\"\\s\", txt)\nz2 = re.split(\"\\s\", txt, 1)\n# Replace all white replacements with 9\na = re.sub(\"\\s\", \"9\", txt)\n# Replace the first 2 occurrences:\na2 = re.sub(\"\\s\", \"9\", txt, 2)\nif x:",
        "detail": "String.regex",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "String.regex",
        "description": "String.regex",
        "peekOfCode": "x = re.search(\"rain\", txt)\ny = re.findall(\"rain\", txt)\nz = re.split(\"\\s\", txt)\nz2 = re.split(\"\\s\", txt, 1)\n# Replace all white replacements with 9\na = re.sub(\"\\s\", \"9\", txt)\n# Replace the first 2 occurrences:\na2 = re.sub(\"\\s\", \"9\", txt, 2)\nif x:\n    print(x)",
        "detail": "String.regex",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "String.regex",
        "description": "String.regex",
        "peekOfCode": "y = re.findall(\"rain\", txt)\nz = re.split(\"\\s\", txt)\nz2 = re.split(\"\\s\", txt, 1)\n# Replace all white replacements with 9\na = re.sub(\"\\s\", \"9\", txt)\n# Replace the first 2 occurrences:\na2 = re.sub(\"\\s\", \"9\", txt, 2)\nif x:\n    print(x)\n    print(x.span())",
        "detail": "String.regex",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "String.regex",
        "description": "String.regex",
        "peekOfCode": "z = re.split(\"\\s\", txt)\nz2 = re.split(\"\\s\", txt, 1)\n# Replace all white replacements with 9\na = re.sub(\"\\s\", \"9\", txt)\n# Replace the first 2 occurrences:\na2 = re.sub(\"\\s\", \"9\", txt, 2)\nif x:\n    print(x)\n    print(x.span())\nif y:",
        "detail": "String.regex",
        "documentation": {}
    },
    {
        "label": "z2",
        "kind": 5,
        "importPath": "String.regex",
        "description": "String.regex",
        "peekOfCode": "z2 = re.split(\"\\s\", txt, 1)\n# Replace all white replacements with 9\na = re.sub(\"\\s\", \"9\", txt)\n# Replace the first 2 occurrences:\na2 = re.sub(\"\\s\", \"9\", txt, 2)\nif x:\n    print(x)\n    print(x.span())\nif y:\n    print(y)",
        "detail": "String.regex",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "String.regex",
        "description": "String.regex",
        "peekOfCode": "a = re.sub(\"\\s\", \"9\", txt)\n# Replace the first 2 occurrences:\na2 = re.sub(\"\\s\", \"9\", txt, 2)\nif x:\n    print(x)\n    print(x.span())\nif y:\n    print(y)\nif z:\n    print(z)",
        "detail": "String.regex",
        "documentation": {}
    },
    {
        "label": "a2",
        "kind": 5,
        "importPath": "String.regex",
        "description": "String.regex",
        "peekOfCode": "a2 = re.sub(\"\\s\", \"9\", txt, 2)\nif x:\n    print(x)\n    print(x.span())\nif y:\n    print(y)\nif z:\n    print(z)\nif z2:\n    print(z2)",
        "detail": "String.regex",
        "documentation": {}
    }
]